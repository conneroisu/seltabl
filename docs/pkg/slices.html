<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: slices</title>
<link href="../css/auto-v0.6.8.css" rel="stylesheet">
<script src="../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>slices</b></span>

<span class="title">Import Path</span>
	<a href="../index.html#pkg-slices">slices</a><i> (on <a href="https://pkg.go.dev/slices" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../dep/slices.html">3 packages</a>, and imported by <a href="../dep/slices.html#imported-by">4 packages</a>

<div id="files"><span class="title">Involved Source Files</span>

	<input type='checkbox' checked class="fold" id="file-0-fold-content"><label for="file-0-fold-content">  <a href="../src/slices/slices.go.html#doc">d</a> <a href="../src/slices/slices.go.html">slices.go</a></label><span id='file-0-fold-content-items' class="fold-items">
<span class="md-text">		Package slices defines various functions useful with slices of any type.</span>
</span>
	<span class="nodocs">    <a href="../src/slices/sort.go.html">sort.go</a></span>
	<span class="nodocs">    <a href="../src/slices/zsortanyfunc.go.html">zsortanyfunc.go</a></span>
	<span class="nodocs">    <a href="../src/slices/zsortordered.go.html">zsortordered.go</a></span></div>
<div id="examples"><span class="title">Code Examples</span>

	<input type='checkbox' class="fold" id="example-0-fold-content"><label for="example-0-fold-content">BinarySearch</label><span id='example-0-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			names := []string{"Alice", "Bob", "Vera"}
			n, found := slices.BinarySearch(names, "Vera")
			fmt.Println("Vera:", n, found)
			n, found = slices.BinarySearch(names, "Bill")
			fmt.Println("Bill:", n, found)
		}
</span>
	<input type='checkbox' class="fold" id="example-1-fold-content"><label for="example-1-fold-content">BinarySearchFunc</label><span id='example-1-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
		)
		
		func main() {
			type Person struct {
				Name string
				Age  int
			}
			people := []Person{
				{"Alice", 55},
				{"Bob", 24},
				{"Gopher", 13},
			}
			n, found := slices.BinarySearchFunc(people, Person{"Bob", 0}, func(a, b Person) int {
				return cmp.Compare(a.Name, b.Name)
			})
			fmt.Println("Bob:", n, found)
		}
</span>
	<input type='checkbox' class="fold" id="example-2-fold-content"><label for="example-2-fold-content">Compact</label><span id='example-2-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			seq := []int{0, 1, 1, 2, 3, 5, 8}
			seq = slices.Compact(seq)
			fmt.Println(seq)
		}
</span>
	<input type='checkbox' class="fold" id="example-3-fold-content"><label for="example-3-fold-content">CompactFunc</label><span id='example-3-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
			"strings"
		)
		
		func main() {
			names := []string{"bob", "Bob", "alice", "Vera", "VERA"}
			names = slices.CompactFunc(names, strings.EqualFold)
			fmt.Println(names)
		}
</span>
	<input type='checkbox' class="fold" id="example-4-fold-content"><label for="example-4-fold-content">Compare</label><span id='example-4-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			names := []string{"Alice", "Bob", "Vera"}
			fmt.Println("Equal:", slices.Compare(names, []string{"Alice", "Bob", "Vera"}))
			fmt.Println("V &lt; X:", slices.Compare(names, []string{"Alice", "Bob", "Xena"}))
			fmt.Println("V &gt; C:", slices.Compare(names, []string{"Alice", "Bob", "Cat"}))
			fmt.Println("3 &gt; 2:", slices.Compare(names, []string{"Alice", "Bob"}))
		}
</span>
	<input type='checkbox' class="fold" id="example-5-fold-content"><label for="example-5-fold-content">CompareFunc</label><span id='example-5-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
			"strconv"
		)
		
		func main() {
			numbers := []int{0, 43, 8}
			strings := []string{"0", "0", "8"}
			result := slices.CompareFunc(numbers, strings, func(n int, s string) int {
				sn, err := strconv.Atoi(s)
				if err != nil {
					return 1
				}
				return cmp.Compare(n, sn)
			})
			fmt.Println(result)
		}
</span>
	<input type='checkbox' class="fold" id="example-6-fold-content"><label for="example-6-fold-content">ContainsFunc</label><span id='example-6-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			numbers := []int{0, 42, -10, 8}
			hasNegative := slices.ContainsFunc(numbers, func(n int) bool {
				return n &lt; 0
			})
			fmt.Println("Has a negative:", hasNegative)
			hasOdd := slices.ContainsFunc(numbers, func(n int) bool {
				return n%2 != 0
			})
			fmt.Println("Has an odd number:", hasOdd)
		}
</span>
	<input type='checkbox' class="fold" id="example-7-fold-content"><label for="example-7-fold-content">Delete</label><span id='example-7-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			letters := []string{"a", "b", "c", "d", "e"}
			letters = slices.Delete(letters, 1, 4)
			fmt.Println(letters)
		}
</span>
	<input type='checkbox' class="fold" id="example-8-fold-content"><label for="example-8-fold-content">DeleteFunc</label><span id='example-8-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			seq := []int{0, 1, 1, 2, 3, 5, 8}
			seq = slices.DeleteFunc(seq, func(n int) bool {
				return n%2 != 0 // delete the odd numbers
			})
			fmt.Println(seq)
		}
</span>
	<input type='checkbox' class="fold" id="example-9-fold-content"><label for="example-9-fold-content">Equal</label><span id='example-9-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			numbers := []int{0, 42, 8}
			fmt.Println(slices.Equal(numbers, []int{0, 42, 8}))
			fmt.Println(slices.Equal(numbers, []int{10}))
		}
</span>
	<input type='checkbox' class="fold" id="example-10-fold-content"><label for="example-10-fold-content">EqualFunc</label><span id='example-10-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
			"strconv"
		)
		
		func main() {
			numbers := []int{0, 42, 8}
			strings := []string{"000", "42", "0o10"}
			equal := slices.EqualFunc(numbers, strings, func(n int, s string) bool {
				sn, err := strconv.ParseInt(s, 0, 64)
				if err != nil {
					return false
				}
				return n == int(sn)
			})
			fmt.Println(equal)
		}
</span>
	<input type='checkbox' class="fold" id="example-11-fold-content"><label for="example-11-fold-content">Index</label><span id='example-11-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			numbers := []int{0, 42, 8}
			fmt.Println(slices.Index(numbers, 8))
			fmt.Println(slices.Index(numbers, 7))
		}
</span>
	<input type='checkbox' class="fold" id="example-12-fold-content"><label for="example-12-fold-content">IndexFunc</label><span id='example-12-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			numbers := []int{0, 42, -10, 8}
			i := slices.IndexFunc(numbers, func(n int) bool {
				return n &lt; 0
			})
			fmt.Println("First negative at index", i)
		}
</span>
	<input type='checkbox' class="fold" id="example-13-fold-content"><label for="example-13-fold-content">Insert</label><span id='example-13-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			names := []string{"Alice", "Bob", "Vera"}
			names = slices.Insert(names, 1, "Bill", "Billie")
			names = slices.Insert(names, len(names), "Zac")
			fmt.Println(names)
		}
</span>
	<input type='checkbox' class="fold" id="example-14-fold-content"><label for="example-14-fold-content">IsSorted</label><span id='example-14-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			fmt.Println(slices.IsSorted([]string{"Alice", "Bob", "Vera"}))
			fmt.Println(slices.IsSorted([]int{0, 2, 1}))
		}
</span>
	<input type='checkbox' class="fold" id="example-15-fold-content"><label for="example-15-fold-content">IsSortedFunc</label><span id='example-15-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
			"strings"
		)
		
		func main() {
			names := []string{"alice", "Bob", "VERA"}
			isSortedInsensitive := slices.IsSortedFunc(names, func(a, b string) int {
				return cmp.Compare(strings.ToLower(a), strings.ToLower(b))
			})
			fmt.Println(isSortedInsensitive)
			fmt.Println(slices.IsSorted(names))
		}
</span>
	<input type='checkbox' class="fold" id="example-16-fold-content"><label for="example-16-fold-content">Max</label><span id='example-16-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			numbers := []int{0, 42, -10, 8}
			fmt.Println(slices.Max(numbers))
		}
</span>
	<input type='checkbox' class="fold" id="example-17-fold-content"><label for="example-17-fold-content">MaxFunc</label><span id='example-17-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
		)
		
		func main() {
			type Person struct {
				Name string
				Age  int
			}
			people := []Person{
				{"Gopher", 13},
				{"Alice", 55},
				{"Vera", 24},
				{"Bob", 55},
			}
			firstOldest := slices.MaxFunc(people, func(a, b Person) int {
				return cmp.Compare(a.Age, b.Age)
			})
			fmt.Println(firstOldest.Name)
		}
</span>
	<input type='checkbox' class="fold" id="example-18-fold-content"><label for="example-18-fold-content">Min</label><span id='example-18-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			numbers := []int{0, 42, -10, 8}
			fmt.Println(slices.Min(numbers))
		}
</span>
	<input type='checkbox' class="fold" id="example-19-fold-content"><label for="example-19-fold-content">MinFunc</label><span id='example-19-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
		)
		
		func main() {
			type Person struct {
				Name string
				Age  int
			}
			people := []Person{
				{"Gopher", 13},
				{"Bob", 5},
				{"Vera", 24},
				{"Bill", 5},
			}
			firstYoungest := slices.MinFunc(people, func(a, b Person) int {
				return cmp.Compare(a.Age, b.Age)
			})
			fmt.Println(firstYoungest.Name)
		}
</span>
	<input type='checkbox' class="fold" id="example-20-fold-content"><label for="example-20-fold-content">Replace</label><span id='example-20-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			names := []string{"Alice", "Bob", "Vera", "Zac"}
			names = slices.Replace(names, 1, 3, "Bill", "Billie", "Cat")
			fmt.Println(names)
		}
</span>
	<input type='checkbox' class="fold" id="example-21-fold-content"><label for="example-21-fold-content">Reverse</label><span id='example-21-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			names := []string{"alice", "Bob", "VERA"}
			slices.Reverse(names)
			fmt.Println(names)
		}
</span>
	<input type='checkbox' class="fold" id="example-22-fold-content"><label for="example-22-fold-content">Sort</label><span id='example-22-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"slices"
		)
		
		func main() {
			smallInts := []int8{0, 42, -10, 8}
			slices.Sort(smallInts)
			fmt.Println(smallInts)
		}
</span>
	<input type='checkbox' class="fold" id="example-23-fold-content"><label for="example-23-fold-content">SortFunc_caseInsensitive</label><span id='example-23-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
			"strings"
		)
		
		func main() {
			names := []string{"Bob", "alice", "VERA"}
			slices.SortFunc(names, func(a, b string) int {
				return cmp.Compare(strings.ToLower(a), strings.ToLower(b))
			})
			fmt.Println(names)
		}
</span>
	<input type='checkbox' class="fold" id="example-24-fold-content"><label for="example-24-fold-content">SortFunc_multiField</label><span id='example-24-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
		)
		
		func main() {
			type Person struct {
				Name string
				Age  int
			}
			people := []Person{
				{"Gopher", 13},
				{"Alice", 55},
				{"Bob", 24},
				{"Alice", 20},
			}
			slices.SortFunc(people, func(a, b Person) int {
				if n := cmp.Compare(a.Name, b.Name); n != 0 {
					return n
				}
				// If names are equal, order by age
				return cmp.Compare(a.Age, b.Age)
			})
			fmt.Println(people)
		}
</span>
	<input type='checkbox' class="fold" id="example-25-fold-content"><label for="example-25-fold-content">SortStableFunc</label><span id='example-25-fold-content-items' class="fold-items">
		package main
		
		import (
			"cmp"
			"fmt"
			"slices"
		)
		
		func main() {
			type Person struct {
				Name string
				Age  int
			}
			people := []Person{
				{"Gopher", 13},
				{"Alice", 20},
				{"Bob", 24},
				{"Alice", 55},
			}
			// Stable sort by name, keeping age ordering of Alices intact
			slices.SortStableFunc(people, func(a, b Person) int {
				return cmp.Compare(a.Name, b.Name)
			})
			fmt.Println(people)
		}
</span>
</div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (total 2, neither is exported)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort exporteds by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div></div><div>	<input type='checkbox' class="showhide" id="unexported-typenames-showhide"><i><label for="unexported-typenames-showhide" class="show-inline">/* 2 unexporteds ... */</label><label for="unexported-typenames-showhide" class="hide-inline">/* 2 unexporteds: */</label></i><div class="anchor type-res hidden" id="name-sortedHint" data-popularity="165">	<input type='checkbox' class="fold" id="sortedHint-fold-content"><label for="sortedHint-fold-content"> <a href="../use/slices..sortedHint^d3606.html">type</a> <a href="../src/slices/sort.go.html#line-168">sortedHint</a> <a href="builtin.html#name-int">int</a> <i>(basic type)</i></label><span id='sortedHint-fold-content-docs' class="fold-docs">

		<input type='checkbox' class="fold" id="sortedHint-fold-results"><label for="sortedHint-fold-results">As Outputs Of (<i>at least 2, neither is exported</i>)</label><span id='sortedHint-fold-results-items' class="fold-items">
			<input type='checkbox' checked class="showhide" id="sortedHint-showhide-inputofs"><i><label for="sortedHint-showhide-inputofs" class="show-inline">/* 2+ unexporteds ... */</label><label for="sortedHint-showhide-inputofs" class="hide-inline">/* 2+ unexporteds: */</label></i><span class="hidden"><i>
			func <a href="#name-choosePivotCmpFunc">choosePivotCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) (pivot <a href="builtin.html#name-int">int</a>, hint <b>sortedHint</b>)</i></span><span class="hidden"><i>
			func <a href="#name-choosePivotOrdered">choosePivotOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>) (pivot <a href="builtin.html#name-int">int</a>, hint <b>sortedHint</b>)</i></span></span>
		<input type='checkbox' class="fold" id="sortedHint-fold-values"><label for="sortedHint-fold-values">As Types Of (<i>total 3, none are exported</i>)</label><span id='sortedHint-fold-values-items' class="fold-items">
			<input type='checkbox' checked class="showhide" id="sortedHint-showhide-values"><i><label for="sortedHint-showhide-values" class="show-inline">/* 3 unexporteds ... */</label><label for="sortedHint-showhide-values" class="hide-inline">/* 3 unexporteds: */</label></i><span class="hidden"><i>
			const <a href="#name-decreasingHint">decreasingHint</a></i></span><span class="hidden"><i>
			const <a href="#name-increasingHint">increasingHint</a></i></span><span class="hidden"><i>
			const <a href="#name-unknownHint">unknownHint</a></i></span></span>

</span></div><div class="anchor type-res hidden" id="name-xorshift" data-popularity="50">	<input type='checkbox' class="fold" id="xorshift-fold-content"><label for="xorshift-fold-content"> <a href="../use/slices..xorshift^c13c5.html">type</a> <a href="../src/slices/sort.go.html#line-177">xorshift</a> <a href="builtin.html#name-uint64">uint64</a> <i>(basic type)</i></label><span id='xorshift-fold-content-docs' class="fold-docs">
<span class="md-text">		xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf</span>

		<input type='checkbox' class="fold" id="xorshift-fold-methods"><label for="xorshift-fold-methods">Methods (<i>only one, which is exported</i>)</label><span id='xorshift-fold-methods-items' class="fold-items"><span>
			<span class="nodocs">(*xorshift) <a href="../src/slices/sort.go.html#line-179">Next</a>() <a href="builtin.html#name-uint64">uint64</a></span></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 71, in which 30 are exported)</i></span></span>

<div class="anchor value-res" id="name-BinarySearch">	<input type='checkbox' class="fold" id="BinarySearch-fold-content"><label for="BinarySearch-fold-content"> <a href="../use/slices..BinarySearch.html">func</a> <a href="../src/slices/sort.go.html#line-124">BinarySearch</a>[S, E](x S, target E) (<a href="builtin.html#name-int">int</a>, <a href="builtin.html#name-bool">bool</a>)</label><span id='BinarySearch-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		BinarySearch searches for target in a sorted slice and returns the position
		where target is found, or the position where target would appear in the
		sort order; it also returns a bool saying whether the target is really found
		in the slice. The slice must be sorted in increasing order.</span>

</span></div><div class="anchor value-res" id="name-BinarySearchFunc">	<input type='checkbox' class="fold" id="BinarySearchFunc-fold-content"><label for="BinarySearchFunc-fold-content"> <a href="../use/slices..BinarySearchFunc.html">func</a> <a href="../src/slices/sort.go.html#line-150">BinarySearchFunc</a>[S, E, T](x S, target T, cmp func(E, T) <a href="builtin.html#name-int">int</a>) (<a href="builtin.html#name-int">int</a>, <a href="builtin.html#name-bool">bool</a>)</label><span id='BinarySearchFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>
			T: <a href="builtin.html#name-any">any</a>

<span class="md-text">		BinarySearchFunc works like [BinarySearch], but uses a custom comparison
		function. The slice must be sorted in increasing order, where "increasing"
		is defined by cmp. cmp should return 0 if the slice element matches
		the target, a negative number if the slice element precedes the target,
		or a positive number if the slice element follows the target.
		cmp must implement the same ordering as the slice, such that if
		cmp(a, t) &lt; 0 and cmp(b, t) &gt;= 0, then a must precede b in the slice.</span>

</span></div><div class="anchor value-res" id="name-Clip">	<input type='checkbox' class="fold" id="Clip-fold-content"><label for="Clip-fold-content"> <a href="../use/slices..Clip.html">func</a> <a href="../src/slices/slices.go.html#line-403">Clip</a>[S, E](s S) S</label><span id='Clip-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Clip removes unused capacity from the slice, returning s[:len(s):len(s)].</span>

</span></div><div class="anchor value-res" id="name-Clone">	<input type='checkbox' class="fold" id="Clone-fold-content"><label for="Clone-fold-content"> <a href="../use/slices..Clone.html">func</a> <a href="../src/slices/slices.go.html#line-341">Clone</a>[S, E](s S) S</label><span id='Clone-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Clone returns a copy of the slice.
		The elements are copied using assignment, so this is a shallow clone.</span>

</span></div><div class="anchor value-res" id="name-Compact">	<input type='checkbox' class="fold" id="Compact-fold-content"><label for="Compact-fold-content"> <a href="../use/slices..Compact.html">func</a> <a href="../src/slices/slices.go.html#line-351">Compact</a>[S, E](s S) S</label><span id='Compact-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-comparable">comparable</a>

<span class="md-text">		Compact replaces consecutive runs of equal elements with a single copy.
		This is like the uniq command found on Unix.
		Compact modifies the contents of the slice s and returns the modified slice,
		which may have a smaller length.
		Compact zeroes the elements between the new length and the original length.</span>

</span></div><div class="anchor value-res" id="name-CompactFunc">	<input type='checkbox' class="fold" id="CompactFunc-fold-content"><label for="CompactFunc-fold-content"> <a href="../use/slices..CompactFunc.html">func</a> <a href="../src/slices/slices.go.html#line-371">CompactFunc</a>[S, E](s S, eq func(E, E) <a href="builtin.html#name-bool">bool</a>) S</label><span id='CompactFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		CompactFunc is like [Compact] but uses an equality function to compare elements.
		For runs of elements that compare equal, CompactFunc keeps the first one.
		CompactFunc zeroes the elements between the new length and the original length.</span>

</span></div><div class="anchor value-res" id="name-Compare">	<input type='checkbox' class="fold" id="Compare-fold-content"><label for="Compare-fold-content"> <a href="../use/slices..Compare.html">func</a> <a href="../src/slices/slices.go.html#line-55">Compare</a>[S, E](s1, s2 S) <a href="builtin.html#name-int">int</a></label><span id='Compare-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
		of elements. The elements are compared sequentially, starting at index 0,
		until one element is not equal to the other.
		The result of comparing the first non-matching elements is returned.
		If both slices are equal until one of them ends, the shorter slice is
		considered less than the longer one.
		The result is 0 if s1 == s2, -1 if s1 &lt; s2, and +1 if s1 &gt; s2.</span>

</span></div><div class="anchor value-res" id="name-CompareFunc">	<input type='checkbox' class="fold" id="CompareFunc-fold-content"><label for="CompareFunc-fold-content"> <a href="../use/slices..CompareFunc.html">func</a> <a href="../src/slices/slices.go.html#line-76">CompareFunc</a>[S1, S2, E1, E2](s1 S1, s2 S2, cmp func(E1, E2) <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a></label><span id='CompareFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S1: ~[]E1
			S2: ~[]E2
			E1: <a href="builtin.html#name-any">any</a>
			E2: <a href="builtin.html#name-any">any</a>

<span class="md-text">		CompareFunc is like [Compare] but uses a custom comparison function on each
		pair of elements.
		The result is the first non-zero result of cmp; if cmp always
		returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) &lt; len(s2),
		and +1 if len(s1) &gt; len(s2).</span>

</span></div><div class="anchor value-res" id="name-Concat">	<input type='checkbox' class="fold" id="Concat-fold-content"><label for="Concat-fold-content"> <a href="../use/slices..Concat.html">func</a> <a href="../src/slices/slices.go.html#line-502">Concat</a>[S, E](slices ...S) S</label><span id='Concat-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Concat returns a new slice concatenating the passed in slices.</span>

</span></div><div class="anchor value-res" id="name-Contains">	<input type='checkbox' class="fold" id="Contains-fold-content"><label for="Contains-fold-content"> <a href="../use/slices..Contains.html">func</a> <a href="../src/slices/slices.go.html#line-115">Contains</a>[S, E](s S, v E) <a href="builtin.html#name-bool">bool</a></label><span id='Contains-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-comparable">comparable</a>

<span class="md-text">		Contains reports whether v is present in s.</span>

</span></div><div class="anchor value-res" id="name-ContainsFunc">	<input type='checkbox' class="fold" id="ContainsFunc-fold-content"><label for="ContainsFunc-fold-content"> <a href="../use/slices..ContainsFunc.html">func</a> <a href="../src/slices/slices.go.html#line-121">ContainsFunc</a>[S, E](s S, f func(E) <a href="builtin.html#name-bool">bool</a>) <a href="builtin.html#name-bool">bool</a></label><span id='ContainsFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		ContainsFunc reports whether at least one
		element e of s satisfies f(e).</span>

</span></div><div class="anchor value-res" id="name-Delete">	<input type='checkbox' class="fold" id="Delete-fold-content"><label for="Delete-fold-content"> <a href="../use/slices..Delete.html">func</a> <a href="../src/slices/slices.go.html#line-218">Delete</a>[S, E](s S, i, j <a href="builtin.html#name-int">int</a>) S</label><span id='Delete-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Delete removes the elements s[i:j] from s, returning the modified slice.
		Delete panics if j &gt; len(s) or s[i:j] is not a valid slice of s.
		Delete is O(len(s)-i), so if many items must be deleted, it is better to
		make a single call deleting them all together than to delete one at a time.
		Delete zeroes the elements s[len(s)-(j-i):len(s)].</span>

</span></div><div class="anchor value-res" id="name-DeleteFunc">	<input type='checkbox' class="fold" id="DeleteFunc-fold-content"><label for="DeleteFunc-fold-content"> <a href="../use/slices..DeleteFunc.html">func</a> <a href="../src/slices/slices.go.html#line-234">DeleteFunc</a>[S, E](s S, del func(E) <a href="builtin.html#name-bool">bool</a>) S</label><span id='DeleteFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		DeleteFunc removes any elements from s for which del returns true,
		returning the modified slice.
		DeleteFunc zeroes the elements between the new length and the original length.</span>

</span></div><div class="anchor value-res" id="name-Equal">	<input type='checkbox' class="fold" id="Equal-fold-content"><label for="Equal-fold-content"> <a href="../use/slices..Equal.html">func</a> <a href="../src/slices/slices.go.html#line-18">Equal</a>[S, E](s1, s2 S) <a href="builtin.html#name-bool">bool</a></label><span id='Equal-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-comparable">comparable</a>

<span class="md-text">		Equal reports whether two slices are equal: the same length and all
		elements equal. If the lengths are different, Equal returns false.
		Otherwise, the elements are compared in increasing index order, and the
		comparison stops at the first unequal pair.
		Floating point NaNs are not considered equal.</span>

</span></div><div class="anchor value-res" id="name-EqualFunc">	<input type='checkbox' class="fold" id="EqualFunc-fold-content"><label for="EqualFunc-fold-content"> <a href="../use/slices..EqualFunc.html">func</a> <a href="../src/slices/slices.go.html#line-35">EqualFunc</a>[S1, S2, E1, E2](s1 S1, s2 S2, eq func(E1, E2) <a href="builtin.html#name-bool">bool</a>) <a href="builtin.html#name-bool">bool</a></label><span id='EqualFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S1: ~[]E1
			S2: ~[]E2
			E1: <a href="builtin.html#name-any">any</a>
			E2: <a href="builtin.html#name-any">any</a>

<span class="md-text">		EqualFunc reports whether two slices are equal using an equality
		function on each pair of elements. If the lengths are different,
		EqualFunc returns false. Otherwise, the elements are compared in
		increasing index order, and the comparison stops at the first index
		for which eq returns false.</span>

</span></div><div class="anchor value-res" id="name-Grow">	<input type='checkbox' class="fold" id="Grow-fold-content"><label for="Grow-fold-content"> <a href="../use/slices..Grow.html">func</a> <a href="../src/slices/slices.go.html#line-392">Grow</a>[S, E](s S, n <a href="builtin.html#name-int">int</a>) S</label><span id='Grow-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Grow increases the slice's capacity, if necessary, to guarantee space for
		another n elements. After Grow(n), at least n elements can be appended
		to the slice without another allocation. If n is negative or too large to
		allocate the memory, Grow panics.</span>

</span></div><div class="anchor value-res" id="name-Index">	<input type='checkbox' class="fold" id="Index-fold-content"><label for="Index-fold-content"> <a href="../use/slices..Index.html">func</a> <a href="../src/slices/slices.go.html#line-94">Index</a>[S, E](s S, v E) <a href="builtin.html#name-int">int</a></label><span id='Index-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-comparable">comparable</a>

<span class="md-text">		Index returns the index of the first occurrence of v in s,
		or -1 if not present.</span>

</span></div><div class="anchor value-res" id="name-IndexFunc">	<input type='checkbox' class="fold" id="IndexFunc-fold-content"><label for="IndexFunc-fold-content"> <a href="../use/slices..IndexFunc.html">func</a> <a href="../src/slices/slices.go.html#line-105">IndexFunc</a>[S, E](s S, f func(E) <a href="builtin.html#name-bool">bool</a>) <a href="builtin.html#name-int">int</a></label><span id='IndexFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		IndexFunc returns the first index i satisfying f(s[i]),
		or -1 if none do.</span>

</span></div><div class="anchor value-res" id="name-Insert">	<input type='checkbox' class="fold" id="Insert-fold-content"><label for="Insert-fold-content"> <a href="../use/slices..Insert.html">func</a> <a href="../src/slices/slices.go.html#line-132">Insert</a>[S, E](s S, i <a href="builtin.html#name-int">int</a>, v ...E) S</label><span id='Insert-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Insert inserts the values v... into s at index i,
		returning the modified slice.
		The elements at s[i:] are shifted up to make room.
		In the returned slice r, r[i] == v[0],
		and r[i+len(v)] == value originally at r[i].
		Insert panics if i is out of range.
		This function is O(len(s) + len(v)).</span>

</span></div><div class="anchor value-res" id="name-IsSorted">	<input type='checkbox' class="fold" id="IsSorted-fold-content"><label for="IsSorted-fold-content"> <a href="../use/slices..IsSorted.html">func</a> <a href="../src/slices/sort.go.html#line-40">IsSorted</a>[S, E](x S) <a href="builtin.html#name-bool">bool</a></label><span id='IsSorted-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		IsSorted reports whether x is sorted in ascending order.</span>

</span></div><div class="anchor value-res" id="name-IsSortedFunc">	<input type='checkbox' class="fold" id="IsSortedFunc-fold-content"><label for="IsSortedFunc-fold-content"> <a href="../use/slices..IsSortedFunc.html">func</a> <a href="../src/slices/sort.go.html#line-51">IsSortedFunc</a>[S, E](x S, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-bool">bool</a></label><span id='IsSortedFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
		comparison function as defined by [SortFunc].</span>

</span></div><div class="anchor value-res" id="name-Max">	<input type='checkbox' class="fold" id="Max-fold-content"><label for="Max-fold-content"> <a href="../use/slices..Max.html">func</a> <a href="../src/slices/sort.go.html#line-93">Max</a>[S, E](x S) E</label><span id='Max-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		Max returns the maximal value in x. It panics if x is empty.
		For floating-point E, Max propagates NaNs (any NaN value in x
		forces the output to be NaN).</span>

</span></div><div class="anchor value-res" id="name-MaxFunc">	<input type='checkbox' class="fold" id="MaxFunc-fold-content"><label for="MaxFunc-fold-content"> <a href="../use/slices..MaxFunc.html">func</a> <a href="../src/slices/sort.go.html#line-107">MaxFunc</a>[S, E](x S, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) E</label><span id='MaxFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		MaxFunc returns the maximal value in x, using cmp to compare elements.
		It panics if x is empty. If there is more than one maximal element
		according to the cmp function, MaxFunc returns the first one.</span>

</span></div><div class="anchor value-res" id="name-Min">	<input type='checkbox' class="fold" id="Min-fold-content"><label for="Min-fold-content"> <a href="../use/slices..Min.html">func</a> <a href="../src/slices/sort.go.html#line-63">Min</a>[S, E](x S) E</label><span id='Min-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		Min returns the minimal value in x. It panics if x is empty.
		For floating-point numbers, Min propagates NaNs (any NaN value in x
		forces the output to be NaN).</span>

</span></div><div class="anchor value-res" id="name-MinFunc">	<input type='checkbox' class="fold" id="MinFunc-fold-content"><label for="MinFunc-fold-content"> <a href="../use/slices..MinFunc.html">func</a> <a href="../src/slices/sort.go.html#line-77">MinFunc</a>[S, E](x S, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) E</label><span id='MinFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		MinFunc returns the minimal value in x, using cmp to compare elements.
		It panics if x is empty. If there is more than one minimal element
		according to the cmp function, MinFunc returns the first one.</span>

</span></div><div class="anchor value-res" id="name-Replace">	<input type='checkbox' class="fold" id="Replace-fold-content"><label for="Replace-fold-content"> <a href="../use/slices..Replace.html">func</a> <a href="../src/slices/slices.go.html#line-254">Replace</a>[S, E](s S, i, j <a href="builtin.html#name-int">int</a>, v ...E) S</label><span id='Replace-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Replace replaces the elements s[i:j] by the given v, and returns the
		modified slice.
		Replace panics if j &gt; len(s) or s[i:j] is not a valid slice of s.
		When len(v) &lt; (j-i), Replace zeroes the elements between the new length and the original length.</span>

</span></div><div class="anchor value-res" id="name-Reverse">	<input type='checkbox' class="fold" id="Reverse-fold-content"><label for="Reverse-fold-content"> <a href="../use/slices..Reverse.html">func</a> <a href="../src/slices/slices.go.html#line-495">Reverse</a>[S, E](s S)</label><span id='Reverse-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		Reverse reverses the elements of the slice in place.</span>

</span></div><div class="anchor value-res" id="name-Sort">	<input type='checkbox' class="fold" id="Sort-fold-content"><label for="Sort-fold-content"> <a href="../use/slices..Sort.html">func</a> <a href="../src/slices/sort.go.html#line-16">Sort</a>[S, E](x S)</label><span id='Sort-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		Sort sorts a slice of any ordered type in ascending order.
		When sorting floating-point numbers, NaNs are ordered before other values.</span>

</span></div><div class="anchor value-res" id="name-SortFunc">	<input type='checkbox' class="fold" id="SortFunc-fold-content"><label for="SortFunc-fold-content"> <a href="../use/slices..SortFunc.html">func</a> <a href="../src/slices/sort.go.html#line-28">SortFunc</a>[S, E](x S, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='SortFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		SortFunc sorts the slice x in ascending order as determined by the cmp
		function. This sort is not guaranteed to be stable.
		cmp(a, b) should return a negative number when a &lt; b, a positive number when
		a &gt; b and zero when a == b.
		
		SortFunc requires that cmp is a strict weak ordering.
		See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.</span>

</span></div><div class="anchor value-res" id="name-SortStableFunc">	<input type='checkbox' class="fold" id="SortStableFunc-fold-content"><label for="SortStableFunc-fold-content"> <a href="../use/slices..SortStableFunc.html">func</a> <a href="../src/slices/sort.go.html#line-35">SortStableFunc</a>[S, E](x S, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='SortStableFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			S: ~[]E
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		SortStableFunc sorts the slice x while keeping the original order of equal
		elements, using cmp to compare elements in the same way as [SortFunc].</span>

</span></div>	<input type='checkbox' class="showhide" id="unexported-functions-showhide"><i><label for="unexported-functions-showhide" class="show-inline">/* 41 unexporteds ... */</label><label for="unexported-functions-showhide" class="hide-inline">/* 41 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-breakPatternsCmpFunc"><i>	<input type='checkbox' class="fold" id="breakPatternsCmpFunc-fold-content"><label for="breakPatternsCmpFunc-fold-content"> <a href="../use/slices..breakPatternsCmpFunc^52e8d.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-240">breakPatternsCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='breakPatternsCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
		that might cause imbalanced partitions in quicksort.</span>

</span></i></div><div class="anchor value-res hidden" id="name-breakPatternsOrdered"><i>	<input type='checkbox' class="fold" id="breakPatternsOrdered-fold-content"><label for="breakPatternsOrdered-fold-content"> <a href="../use/slices..breakPatternsOrdered^e04be.html">func</a> <a href="../src/slices/zsortordered.go.html#line-242">breakPatternsOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>)</label><span id='breakPatternsOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		breakPatternsOrdered scatters some elements around in an attempt to break some patterns
		that might cause imbalanced partitions in quicksort.</span>

</span></i></div><div class="anchor value-res hidden" id="name-choosePivotCmpFunc"><i>	<input type='checkbox' class="fold" id="choosePivotCmpFunc-fold-content"><label for="choosePivotCmpFunc-fold-content"> <a href="../use/slices..choosePivotCmpFunc^3d47f.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-261">choosePivotCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) (pivot <a href="builtin.html#name-int">int</a>, hint <a href="#name-sortedHint">sortedHint</a>)</label><span id='choosePivotCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		choosePivotCmpFunc chooses a pivot in data[a:b].
		
		[0,8): chooses a static pivot.
		[8,shortestNinther): uses the simple median-of-three method.
		[shortestNinther,∞): uses the Tukey ninther method.</span>

</span></i></div><div class="anchor value-res hidden" id="name-choosePivotOrdered"><i>	<input type='checkbox' class="fold" id="choosePivotOrdered-fold-content"><label for="choosePivotOrdered-fold-content"> <a href="../use/slices..choosePivotOrdered^17ece.html">func</a> <a href="../src/slices/zsortordered.go.html#line-263">choosePivotOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>) (pivot <a href="builtin.html#name-int">int</a>, hint <a href="#name-sortedHint">sortedHint</a>)</label><span id='choosePivotOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		choosePivotOrdered chooses a pivot in data[a:b].
		
		[0,8): chooses a static pivot.
		[8,shortestNinther): uses the simple median-of-three method.
		[shortestNinther,∞): uses the Tukey ninther method.</span>

</span></i></div><div class="anchor value-res hidden" id="name-heapSortCmpFunc"><i>	<input type='checkbox' class="fold" id="heapSortCmpFunc-fold-content"><label for="heapSortCmpFunc-fold-content"> <a href="../use/slices..heapSortCmpFunc^1fc1a.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-38">heapSortCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='heapSortCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

</span></i></div><div class="anchor value-res hidden" id="name-heapSortOrdered"><i>	<input type='checkbox' class="fold" id="heapSortOrdered-fold-content"><label for="heapSortOrdered-fold-content"> <a href="../use/slices..heapSortOrdered^2c0c4.html">func</a> <a href="../src/slices/zsortordered.go.html#line-40">heapSortOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>)</label><span id='heapSortOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

</span></i></div><div class="anchor value-res hidden" id="name-insertionSortCmpFunc"><i>	<input type='checkbox' class="fold" id="insertionSortCmpFunc-fold-content"><label for="insertionSortCmpFunc-fold-content"> <a href="../use/slices..insertionSortCmpFunc^8ccdd.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-10">insertionSortCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='insertionSortCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		insertionSortCmpFunc sorts data[a:b] using insertion sort.</span>

</span></i></div><div class="anchor value-res hidden" id="name-insertionSortOrdered"><i>	<input type='checkbox' class="fold" id="insertionSortOrdered-fold-content"><label for="insertionSortOrdered-fold-content"> <a href="../use/slices..insertionSortOrdered^b0684.html">func</a> <a href="../src/slices/zsortordered.go.html#line-12">insertionSortOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>)</label><span id='insertionSortOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		insertionSortOrdered sorts data[a:b] using insertion sort.</span>

</span></i></div><div class="anchor value-res hidden" id="name-isNaN"><i>	<input type='checkbox' class="fold" id="isNaN-fold-content"><label for="isNaN-fold-content"> <a href="../use/slices..isNaN^c4c55.html">func</a> <a href="../src/slices/sort.go.html#line-192">isNaN</a>[T](x T) <a href="builtin.html#name-bool">bool</a></label><span id='isNaN-fold-content-docs' class="fold-docs">

		Type Parameters:
			T: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		isNaN reports whether x is a NaN without requiring the math package.
		This will always return false if T is not floating-point.</span>

</span></i></div><div class="anchor value-res hidden" id="name-medianAdjacentCmpFunc"><i>	<input type='checkbox' class="fold" id="medianAdjacentCmpFunc-fold-content"><label for="medianAdjacentCmpFunc-fold-content"> <a href="../use/slices..medianAdjacentCmpFunc^7dbd5.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-315">medianAdjacentCmpFunc</a>[E](data []E, a <a href="builtin.html#name-int">int</a>, swaps *<a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a></label><span id='medianAdjacentCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</span>

</span></i></div><div class="anchor value-res hidden" id="name-medianAdjacentOrdered"><i>	<input type='checkbox' class="fold" id="medianAdjacentOrdered-fold-content"><label for="medianAdjacentOrdered-fold-content"> <a href="../use/slices..medianAdjacentOrdered^85fcd.html">func</a> <a href="../src/slices/zsortordered.go.html#line-317">medianAdjacentOrdered</a>[E](data []E, a <a href="builtin.html#name-int">int</a>, swaps *<a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a></label><span id='medianAdjacentOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		medianAdjacentOrdered finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</span>

</span></i></div><div class="anchor value-res hidden" id="name-medianCmpFunc"><i>	<input type='checkbox' class="fold" id="medianCmpFunc-fold-content"><label for="medianCmpFunc-fold-content"> <a href="../use/slices..medianCmpFunc^280f3.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-307">medianCmpFunc</a>[E](data []E, a, b, c <a href="builtin.html#name-int">int</a>, swaps *<a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a></label><span id='medianCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</span>

</span></i></div><div class="anchor value-res hidden" id="name-medianOrdered"><i>	<input type='checkbox' class="fold" id="medianOrdered-fold-content"><label for="medianOrdered-fold-content"> <a href="../use/slices..medianOrdered^7a655.html">func</a> <a href="../src/slices/zsortordered.go.html#line-309">medianOrdered</a>[E](data []E, a, b, c <a href="builtin.html#name-int">int</a>, swaps *<a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a></label><span id='medianOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		medianOrdered returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nextPowerOfTwo"><i>	<span class="nodocs"> <a href="../use/slices..nextPowerOfTwo^1e976.html">func</a> <a href="../src/slices/sort.go.html#line-186">nextPowerOfTwo</a>(length <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-uint">uint</a></span></i></div><div class="anchor value-res hidden" id="name-order2CmpFunc"><i>	<input type='checkbox' class="fold" id="order2CmpFunc-fold-content"><label for="order2CmpFunc-fold-content"> <a href="../use/slices..order2CmpFunc^93eee.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-298">order2CmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, swaps *<a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) (<a href="builtin.html#name-int">int</a>, <a href="builtin.html#name-int">int</a>)</label><span id='order2CmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		order2CmpFunc returns x,y where data[x] &lt;= data[y], where x,y=a,b or x,y=b,a.</span>

</span></i></div><div class="anchor value-res hidden" id="name-order2Ordered"><i>	<input type='checkbox' class="fold" id="order2Ordered-fold-content"><label for="order2Ordered-fold-content"> <a href="../use/slices..order2Ordered^4b849.html">func</a> <a href="../src/slices/zsortordered.go.html#line-300">order2Ordered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, swaps *<a href="builtin.html#name-int">int</a>) (<a href="builtin.html#name-int">int</a>, <a href="builtin.html#name-int">int</a>)</label><span id='order2Ordered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		order2Ordered returns x,y where data[x] &lt;= data[y], where x,y=a,b or x,y=b,a.</span>

</span></i></div><div class="anchor value-res hidden" id="name-overlaps"><i>	<input type='checkbox' class="fold" id="overlaps-fold-content"><label for="overlaps-fold-content"> <a href="../use/slices..overlaps^2db27.html">func</a> <a href="../src/slices/slices.go.html#line-467">overlaps</a>[E](a, b []E) <a href="builtin.html#name-bool">bool</a></label><span id='overlaps-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		overlaps reports whether the memory ranges a[0:len(a)] and b[0:len(b)] overlap.</span>

</span></i></div><div class="anchor value-res hidden" id="name-partialInsertionSortCmpFunc"><i>	<input type='checkbox' class="fold" id="partialInsertionSortCmpFunc-fold-content"><label for="partialInsertionSortCmpFunc-fold-content"> <a href="../use/slices..partialInsertionSortCmpFunc^aadb6.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-195">partialInsertionSortCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-bool">bool</a></label><span id='partialInsertionSortCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.</span>

</span></i></div><div class="anchor value-res hidden" id="name-partialInsertionSortOrdered"><i>	<input type='checkbox' class="fold" id="partialInsertionSortOrdered-fold-content"><label for="partialInsertionSortOrdered-fold-content"> <a href="../use/slices..partialInsertionSortOrdered^d857d.html">func</a> <a href="../src/slices/zsortordered.go.html#line-197">partialInsertionSortOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-bool">bool</a></label><span id='partialInsertionSortOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		partialInsertionSortOrdered partially sorts a slice, returns true if the slice is sorted at the end.</span>

</span></i></div><div class="anchor value-res hidden" id="name-partitionCmpFunc"><i>	<input type='checkbox' class="fold" id="partitionCmpFunc-fold-content"><label for="partitionCmpFunc-fold-content"> <a href="../use/slices..partitionCmpFunc^53694.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-135">partitionCmpFunc</a>[E](data []E, a, b, pivot <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) (newpivot <a href="builtin.html#name-int">int</a>, alreadyPartitioned <a href="builtin.html#name-bool">bool</a>)</label><span id='partitionCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		partitionCmpFunc does one quicksort partition.
		Let p = data[pivot]
		Moves elements in data[a:b] around, so that data[i]&lt;p and data[j]&gt;=p for i&lt;newpivot and j&gt;newpivot.
		On return, data[newpivot] = p</span>

</span></i></div><div class="anchor value-res hidden" id="name-partitionEqualCmpFunc"><i>	<input type='checkbox' class="fold" id="partitionEqualCmpFunc-fold-content"><label for="partitionEqualCmpFunc-fold-content"> <a href="../use/slices..partitionEqualCmpFunc^33b6d.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-173">partitionEqualCmpFunc</a>[E](data []E, a, b, pivot <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>) (newpivot <a href="builtin.html#name-int">int</a>)</label><span id='partitionEqualCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
		It assumed that data[a:b] does not contain elements smaller than the data[pivot].</span>

</span></i></div><div class="anchor value-res hidden" id="name-partitionEqualOrdered"><i>	<input type='checkbox' class="fold" id="partitionEqualOrdered-fold-content"><label for="partitionEqualOrdered-fold-content"> <a href="../use/slices..partitionEqualOrdered^6849c.html">func</a> <a href="../src/slices/zsortordered.go.html#line-175">partitionEqualOrdered</a>[E](data []E, a, b, pivot <a href="builtin.html#name-int">int</a>) (newpivot <a href="builtin.html#name-int">int</a>)</label><span id='partitionEqualOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		partitionEqualOrdered partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
		It assumed that data[a:b] does not contain elements smaller than the data[pivot].</span>

</span></i></div><div class="anchor value-res hidden" id="name-partitionOrdered"><i>	<input type='checkbox' class="fold" id="partitionOrdered-fold-content"><label for="partitionOrdered-fold-content"> <a href="../use/slices..partitionOrdered^a2a9f.html">func</a> <a href="../src/slices/zsortordered.go.html#line-137">partitionOrdered</a>[E](data []E, a, b, pivot <a href="builtin.html#name-int">int</a>) (newpivot <a href="builtin.html#name-int">int</a>, alreadyPartitioned <a href="builtin.html#name-bool">bool</a>)</label><span id='partitionOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		partitionOrdered does one quicksort partition.
		Let p = data[pivot]
		Moves elements in data[a:b] around, so that data[i]&lt;p and data[j]&gt;=p for i&lt;newpivot and j&gt;newpivot.
		On return, data[newpivot] = p</span>

</span></i></div><div class="anchor value-res hidden" id="name-pdqsortCmpFunc"><i>	<input type='checkbox' class="fold" id="pdqsortCmpFunc-fold-content"><label for="pdqsortCmpFunc-fold-content"> <a href="../use/slices..pdqsortCmpFunc^fc250.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-61">pdqsortCmpFunc</a>[E](data []E, a, b, limit <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='pdqsortCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		pdqsortCmpFunc sorts data[a:b].
		The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
		pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
		C++ implementation: https://github.com/orlp/pdqsort
		Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
		limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</span>

</span></i></div><div class="anchor value-res hidden" id="name-pdqsortOrdered"><i>	<input type='checkbox' class="fold" id="pdqsortOrdered-fold-content"><label for="pdqsortOrdered-fold-content"> <a href="../use/slices..pdqsortOrdered^01310.html">func</a> <a href="../src/slices/zsortordered.go.html#line-63">pdqsortOrdered</a>[E](data []E, a, b, limit <a href="builtin.html#name-int">int</a>)</label><span id='pdqsortOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		pdqsortOrdered sorts data[a:b].
		The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
		pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
		C++ implementation: https://github.com/orlp/pdqsort
		Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
		limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</span>

</span></i></div><div class="anchor value-res hidden" id="name-reverseRangeCmpFunc"><i>	<input type='checkbox' class="fold" id="reverseRangeCmpFunc-fold-content"><label for="reverseRangeCmpFunc-fold-content"> <a href="../use/slices..reverseRangeCmpFunc^accda.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-319">reverseRangeCmpFunc</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='reverseRangeCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

</span></i></div><div class="anchor value-res hidden" id="name-reverseRangeOrdered"><i>	<input type='checkbox' class="fold" id="reverseRangeOrdered-fold-content"><label for="reverseRangeOrdered-fold-content"> <a href="../use/slices..reverseRangeOrdered^c26ad.html">func</a> <a href="../src/slices/zsortordered.go.html#line-321">reverseRangeOrdered</a>[E](data []E, a, b <a href="builtin.html#name-int">int</a>)</label><span id='reverseRangeOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

</span></i></div><div class="anchor value-res hidden" id="name-rotateCmpFunc"><i>	<input type='checkbox' class="fold" id="rotateCmpFunc-fold-content"><label for="rotateCmpFunc-fold-content"> <a href="../use/slices..rotateCmpFunc^de987.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-464">rotateCmpFunc</a>[E](data []E, a, m, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='rotateCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
		Data of the form 'x u v y' is changed to 'x v u y'.
		rotate performs at most b-a many calls to data.Swap,
		and it assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.</span>

</span></i></div><div class="anchor value-res hidden" id="name-rotateLeft"><i>	<input type='checkbox' class="fold" id="rotateLeft-fold-content"><label for="rotateLeft-fold-content"> <a href="../use/slices..rotateLeft^aced3.html">func</a> <a href="../src/slices/slices.go.html#line-444">rotateLeft</a>[E](s []E, r <a href="builtin.html#name-int">int</a>)</label><span id='rotateLeft-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		rotateLeft rotates b left by n spaces.
		s_final[i] = s_orig[i+r], wrapping around.</span>

</span></i></div><div class="anchor value-res hidden" id="name-rotateOrdered"><i>	<input type='checkbox' class="fold" id="rotateOrdered-fold-content"><label for="rotateOrdered-fold-content"> <a href="../use/slices..rotateOrdered^7f8cd.html">func</a> <a href="../src/slices/zsortordered.go.html#line-466">rotateOrdered</a>[E](data []E, a, m, b <a href="builtin.html#name-int">int</a>)</label><span id='rotateOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
		Data of the form 'x u v y' is changed to 'x v u y'.
		rotate performs at most b-a many calls to data.Swap,
		and it assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.</span>

</span></i></div><div class="anchor value-res hidden" id="name-rotateRight"><i>	<input type='checkbox' class="fold" id="rotateRight-fold-content"><label for="rotateRight-fold-content"> <a href="../use/slices..rotateRight^d3a0e.html">func</a> <a href="../src/slices/slices.go.html#line-455">rotateRight</a>[E](s []E, r <a href="builtin.html#name-int">int</a>)</label><span id='rotateRight-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

</span></i></div><div class="anchor value-res hidden" id="name-siftDownCmpFunc"><i>	<input type='checkbox' class="fold" id="siftDownCmpFunc-fold-content"><label for="siftDownCmpFunc-fold-content"> <a href="../use/slices..siftDownCmpFunc^6b4dc.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-20">siftDownCmpFunc</a>[E](data []E, lo, hi, first <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='siftDownCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		siftDownCmpFunc implements the heap property on data[lo:hi].
		first is an offset into the array where the root of the heap lies.</span>

</span></i></div><div class="anchor value-res hidden" id="name-siftDownOrdered"><i>	<input type='checkbox' class="fold" id="siftDownOrdered-fold-content"><label for="siftDownOrdered-fold-content"> <a href="../use/slices..siftDownOrdered^56990.html">func</a> <a href="../src/slices/zsortordered.go.html#line-22">siftDownOrdered</a>[E](data []E, lo, hi, first <a href="builtin.html#name-int">int</a>)</label><span id='siftDownOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		siftDownOrdered implements the heap property on data[lo:hi].
		first is an offset into the array where the root of the heap lies.</span>

</span></i></div><div class="anchor value-res hidden" id="name-stableCmpFunc"><i>	<input type='checkbox' class="fold" id="stableCmpFunc-fold-content"><label for="stableCmpFunc-fold-content"> <a href="../use/slices..stableCmpFunc^44382.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-335">stableCmpFunc</a>[E](data []E, n <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='stableCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

</span></i></div><div class="anchor value-res hidden" id="name-stableOrdered"><i>	<input type='checkbox' class="fold" id="stableOrdered-fold-content"><label for="stableOrdered-fold-content"> <a href="../use/slices..stableOrdered^22e03.html">func</a> <a href="../src/slices/zsortordered.go.html#line-337">stableOrdered</a>[E](data []E, n <a href="builtin.html#name-int">int</a>)</label><span id='stableOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

</span></i></div><div class="anchor value-res hidden" id="name-startIdx"><i>	<input type='checkbox' class="fold" id="startIdx-fold-content"><label for="startIdx-fold-content"> <a href="../use/slices..startIdx^01324.html">func</a> <a href="../src/slices/slices.go.html#line-483">startIdx</a>[E](haystack, needle []E) <a href="builtin.html#name-int">int</a></label><span id='startIdx-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		startIdx returns the index in haystack where the needle starts.
		prerequisite: the needle must be aliased entirely inside the haystack.</span>

</span></i></div><div class="anchor value-res hidden" id="name-swap"><i>	<input type='checkbox' class="fold" id="swap-fold-content"><label for="swap-fold-content"> <a href="../use/slices..swap^da47c.html">func</a> <a href="../src/slices/slices.go.html#line-460">swap</a>[E](x, y []E)</label><span id='swap-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		swap swaps the contents of x and y. x and y must be equal length and disjoint.</span>

</span></i></div><div class="anchor value-res hidden" id="name-swapRangeCmpFunc"><i>	<input type='checkbox' class="fold" id="swapRangeCmpFunc-fold-content"><label for="swapRangeCmpFunc-fold-content"> <a href="../use/slices..swapRangeCmpFunc^65d3a.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-329">swapRangeCmpFunc</a>[E](data []E, a, b, n <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='swapRangeCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

</span></i></div><div class="anchor value-res hidden" id="name-swapRangeOrdered"><i>	<input type='checkbox' class="fold" id="swapRangeOrdered-fold-content"><label for="swapRangeOrdered-fold-content"> <a href="../use/slices..swapRangeOrdered^dfd53.html">func</a> <a href="../src/slices/zsortordered.go.html#line-331">swapRangeOrdered</a>[E](data []E, a, b, n <a href="builtin.html#name-int">int</a>)</label><span id='swapRangeOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

</span></i></div><div class="anchor value-res hidden" id="name-symMergeCmpFunc"><i>	<input type='checkbox' class="fold" id="symMergeCmpFunc-fold-content"><label for="symMergeCmpFunc-fold-content"> <a href="../use/slices..symMergeCmpFunc^45362.html">func</a> <a href="../src/slices/zsortanyfunc.go.html#line-378">symMergeCmpFunc</a>[E](data []E, a, m, b <a href="builtin.html#name-int">int</a>, cmp func(a, b E) <a href="builtin.html#name-int">int</a>)</label><span id='symMergeCmpFunc-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="builtin.html#name-any">any</a>

<span class="md-text">		symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
		the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
		Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
		Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
		Computer Science, pages 714-723. Springer, 2004.
		
		Let M = m-a and N = b-n. Wolog M &lt; N.
		The recursion depth is bound by ceil(log(N+M)).
		The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
		The algorithm needs O((M+N)*log(M)) calls to data.Swap.
		
		The paper gives O((M+N)*log(M)) as the number of assignments assuming a
		rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
		in the paper carries through for Swap operations, especially as the block
		swapping rotate uses only O(M+N) Swaps.
		
		symMerge assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.
		Having the caller check this condition eliminates many leaf recursion calls,
		which improves performance.</span>

</span></i></div><div class="anchor value-res hidden" id="name-symMergeOrdered"><i>	<input type='checkbox' class="fold" id="symMergeOrdered-fold-content"><label for="symMergeOrdered-fold-content"> <a href="../use/slices..symMergeOrdered^1cc26.html">func</a> <a href="../src/slices/zsortordered.go.html#line-380">symMergeOrdered</a>[E](data []E, a, m, b <a href="builtin.html#name-int">int</a>)</label><span id='symMergeOrdered-fold-content-docs' class="fold-docs">

		Type Parameters:
			E: <a href="cmp.html">cmp</a>.<a href="cmp.html#name-Ordered">Ordered</a>

<span class="md-text">		symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
		the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
		Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
		Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
		Computer Science, pages 714-723. Springer, 2004.
		
		Let M = m-a and N = b-n. Wolog M &lt; N.
		The recursion depth is bound by ceil(log(N+M)).
		The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
		The algorithm needs O((M+N)*log(M)) calls to data.Swap.
		
		The paper gives O((M+N)*log(M)) as the number of assignments assuming a
		rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
		in the paper carries through for Swap operations, especially as the block
		swapping rotate uses only O(M+N) Swaps.
		
		symMerge assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.
		Having the caller check this condition eliminates many leaf recursion calls,
		which improves performance.</span>

</span></i></div></div>
<div id="exported-constants"><span class="title">Package-Level Constants<span class="title-stat"><i> (total 3, none are exported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-constants-showhide"><i><label for="unexported-constants-showhide" class="show-inline">/* 3 unexporteds ... */</label><label for="unexported-constants-showhide" class="hide-inline">/* 3 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-decreasingHint"><i>	<span class="nodocs"><a href="../use/slices..decreasingHint^b4a73.html">const</a> <a href="../src/slices/sort.go.html#line-173">decreasingHint</a> <a href="#name-sortedHint">sortedHint</a> = 2</span></i></div><div class="anchor value-res hidden" id="name-increasingHint"><i>	<span class="nodocs"><a href="../use/slices..increasingHint^79777.html">const</a> <a href="../src/slices/sort.go.html#line-172">increasingHint</a> <a href="#name-sortedHint">sortedHint</a> = 1</span></i></div><div class="anchor value-res hidden" id="name-unknownHint"><i>	<span class="nodocs"><a href="../use/slices..unknownHint^b1890.html">const</a> <a href="../src/slices/sort.go.html#line-171">unknownHint</a> <a href="#name-sortedHint">sortedHint</a> = 0</span></i></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>