{{/* 
Error Content Template 
*/}}
{{- define "error_prompt" -}}
As a intelligent computer programmer, you are to generate a better error 
message for the given error. Your response should be a description of the error.
In this description, you must include the following:
- The error message
- Where the error occurred while processing the json response
- How to fix the error. (DO not include any code)

Last output:
```json
{{ .Out }}
```

Current error message:
-

We encountered an error while processing your json response.

We encountered the following error:

DO return purely json.
DO provide the defined json schema for the error.
DO NOT return any additional code/json.
DO NOT remove any json keys or values.
DO NOT try to fix the error.

```md
{{ .Error }}
```

-
{{- end -}}

{{/* 
Aggregate Error Content Template 
*/}}
{{- define "error_aggregate" -}}
As an extremely diligent and intelligent programmer, you are to fully describe the given error in an accurate textual response.

Your interns have created a list of error message to replace the given error, but you must congregate them into a single comprehensive response that fully describes the given error.

Remove duplicate error messages, ensure the response is syntactically valid, and 
improve the error message by combining ideas found in the error messages.

{{- range $i, $error := .Errors }}
	{{- if $i }}{{- end }}
```md
{{ $error }}
```
{{- end }}

{{- end -}}


{{/* 
Test Content Template 
*/}}
{{- define "test" -}}
// Code generated by seltabls - DO NOT EDIT
//
// seltabls: version: v{{ .Version }}
package {{ .PackageName }}

import (
	_ "embed"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/conneroisu/seltabl/tools/seltabls/pkg/generate"
	"github.com/conneroisu/seltabl"
)

// {{ .Name }}Seltabl is the seltabl configuration for the {{ .Name }} struct.
//
//go:embed {{ .Name }}_seltabl.yaml
var {{ .Name }}Seltabl string

// Test{{ .Name }} tests the {{ .Name }} struct.
func Test{{ .Name }}(t *testing.T) {
	a := assert.New(t)
	// Read the configuration file.
	var config generate.ConfigFile
	err = generate.ReadConfigFile("{{ .Name }}_seltabl.yaml", &config)
	a.NoError(err)
	body := config.HTMLBody
	result, err := seltabl.NewFromString[{{ .Name }}](body)
	a.NoError(err)
	a.NotNil(result)
}
{{- end -}}

{{/* 
Identify Content Template 
*/}}
{{- define "identify_prompt" -}}
As a extremely diligent assistant, you are to identify sections of the following html that are processable.

Processable sections are sections that contain data that can be extracted from the html.

You are to identify sections of the following html that are processable.

You should return a json object with the following attributes:

- sections: a list of sections of the html that are processable.

sections has the following attributes:

- description: a description of the section. (should describe what the section is for and what it contains)
- start: the start of the section in the html. (line number)
- end: the end of the section in the html. (line number)
- css: the css selector for the section. (should be a valid css selector that can be used to select the entire section in the html)

Example Output:

```json
{
	"sections": [
		{
			"description": "Section contains the stats for the team.",
			"start": 0,
			"end": 10
			"css": "div#contentArea > menu > div:not(:nth-child(1))"
		},
		{
			"description": "Section contains the stats for the team statistical leaders.",
			"start": 10,
			"end": 20
			"css": "div#contentContainer > div.container > div.row > div.col-md-12 > div:nth-child(1)  > div.table-responsive"
		}
	]
}
```

The html is:

```html
{{ .Content }}
```
{{- end -}}

{{/* 
Identify Aggregate Content Template 
*/}}
{{- define "identify_aggregate" -}}
As a diligent and experienced html developer, you are to fully describe the given html content in a comprehensive and accurate json response.

Your interns have created a list of json schemas for the given html content, but you must congregate them into a single comprehensive and accurate json response that fully describes the given html content.

You are to congregate the following json schemas into a single comprehensive and accurate json response that fully describes the given html content.

The url that your interns have created schemas for is: {{ .URL }}

Schemas:

{{- range $i, $response := .Responses }}
	{{- if $i }}{{- end }}
```json
{{ $response }}
```
{{- end }}

The html is:

```html
{{ .Content }}
```
{{- end -}}

{{/* 
Struct File Prompt Template 
*/}}
{{- define "schema_prompt" -}}
You are to generate a json schema for a given url, {{ .URL }}.

The json schema must have a number of attributes for each field in the struct.

{{ .SelectorName }}: {{ .SelectorDescription }}
Key: Desc

- header-selector: used to find the header row and column for the field in the given struct.
- data-selector: used to find the data column for the field in the given struct.
- query-selector: used to query for the inner text or attribute of the cell.
- control-selector: used to control what to query for the inner text or attribute of the cell.
- must-be-present: used to ensure that the field is present in the given url.

Example Output:

```json
{
	"selectors": [
		{
			"name": "Average Exit Velocity",
			"type": "int",
			"description": "The average exit velocity of the player's hits on the team stats page in meters per second. (mps)",
			"header-selector": "tr:nth-child(1) td:nth-child(1)",
			"data-selector": "tr:not(:nth-child(2)) td",
			"control-selector": "$text",
			"query-selector": "$text",
			"must-be-present": "must"
		}
	]
}
```

You must use the given url's html content to generate the golang struct.

Your html content:

{{ .Content }}

Your selectors with attriubutes (meaning without added specifiers; `:nth-child(1)`, `:not(:nth-child(2))`, etc):

```go
{{ .Selectors }}
```
{{- end -}}

{{/* 
Aggregate Section chema Content Template 
Inputs:
- HTMLContent: the html content for the struct
- Schemas: the json schemas for the struct
- Selectors: the valid base value selectors
*/}}
{{- define "schema_aggregate" -}}
As a smart and forgiving computer science professor, your students are creating a comprehensive and
accurate json schema for a given section of html as part of a lab assignment.

You are to cogregate the following json schemas from your students into a single comprehensive and
accurate json schema designed to be used to select elements using css selectors.

- header selector: used to find the header row and column for the field in the given struct.
- data-selector: used to find the data column for the field in the given struct.
- query-selector: used to query for the inner text or attribute of the cell.
- control-selector: used to control what to query for the inner text or attribute of the cell.
- must-be-present: used to ensure that the field is present in the given url.

The valid base value selectors are:

{{ .Selectors }}

Your HTML content:

{{ .HTMLContent }}

Your json schemas:

{{ .Schemas }}
{{- end -}}

{{/* 
Struct File Content Template 
*/}}
{{- define "struct_file" -}}
// Package {{ .PackageName }} is a package for extracting data from {{ .URL }}.
package {{ .PackageName }}

{{- end -}}

{{/*
Struct Content Template 
Inputs:
- URL: the url for the struct
- Name: the name of the struct
- IgnoreElements: the ignore elements for the struct
- Fields: the fields for the struct
*/}}
{{- define "struct_content" -}}
// {{ .Name }} is a struct for a {{ .Name }}
// @url: {{ .URL }}
// @ignore-elements: {{ range $i, $element := .IgnoreElements }}{{ if $i }}, {{ end }}{{ $element }}{{ end }}
type {{ .Name }} struct {
	{{ range $i, $field := .Fields }}
		// {{ $field.Name }} - {{ $field.Description }}
		{{ $field.Name }} {{ $field.Type }} `json:"{{ $field.Name }}" hSel:"{{ $field.HeaderSelector }}" dSel:"{{ $field.DataSelector }}" ctl:"{{ $field.ControlSelector }}" {{ if $field.MustBePresent }}must:"{{ $field.MustBePresent }}"{{ end }}`
	{{ end }}
}}
{{- end -}}
