{{/*
Identify Error Template
================================================================================
*/}}
{{- define "decode_error" -}}
We encountered an error while processing your response.

In reponse to this error, you must return the entire fixed json response and 
nothing else. 

DO NOT remove any json keys or values.

More details:
{{ .Message }}

We encountered the following error:

```text
{{ .Error }}
```


{{- end -}}

{{/*
Section Error Template
================================================================================
*/}}
{{- define "section_error" -}}
As a extremely intelligent assistant for ai models, your are to improve the following error given to a 
llama3 or gpt4 model.

The error arising from the agents last response is:
{{ .Error }}.

Your task is to improve the error given to a llama3 or gpt4 model by providing detailed information within the current conversation context.

The current conversation:
{{- end -}} {{/* append history */}}

{{/*
Section Aggregate Template
================================================================================
*/}}
{{- define "section_aggregate" -}}
Please provide a single JSON object that aggregates the following multiple JSON structures.
The aggregated JSON object should combine all the fields from the above structures.
If there are any conflicting fields, please ensure they are merged appropriately.

You should return a json object with the following attributes:

- name: the golang struct name for the section (should be a valid golang struct name).
- sections: a list of sections of the html that are processable.
\- description: a description of the section (should describe what the section is for and what it contains).
\- css: the css selector for the section (should be a valid css selector to select the entire section in the html).

The global base selectors are:

{{- range $i, $sel := .Selectors }}
	{{- if $i }}{{- end }}
- {{ $sel.Value }}
{{- end }}

Example:

```json
{
	"name": "softball-ncaa-stats-team-results",
	"sections": [
		{
			"description": "Section contains the stats for the team.",
			"css": "html body table#dataTable tr:nth-child(1) td:nth-child(1)"
		},
		{
			"description": "Section contains the stats for the team statistical leaders.",
			"css": "html > body > div#contentContainer > div.container > div.row > div.col-md-12 > div:nth-child(1)  > div.table-responsive"
		}
	]
}

{{- range .Structs }}
```json
- {{ . }}
```
{{- end }}

The aggregated JSON object should combine all the fields from the above structures. If there are any conflicting fields, please ensure they are merged appropriately.

The aggergated sections returned should be for the entire html:
```html
{{ .Content }}
```
Input JSON structures:

{{- range .Structs }}
```json
{{ . }}
```
{{- end }}
{{- end -}}

{{/*
Identify Prompt Template
================================================================================
*/}}
{{- define "identify_prompt" -}}
As a extremely diligent web developer, you are to identify sections of the following formated and ruled html that contain good examples of statistics.
Good examples of statistics are sections that contain data that can be extracted from the html that could be used to perform data science.

You must only return {{ .NumSections }} sections of the html that contain good examples of statistics.

DO NOT include any extraneous features in the returned json object.
Your json object must only contain the following attributes:

- name: the struct name for the section (should be a valid golang struct name).
- sections: a list of sections of the html that are processable.
\- description: a description of the section. (should describe what the section is for and what it contains)
\- css: the css selector for the section. (should be a valid css selector that can be used to select the entire section in the html)

Example Output showing 2 sections:

```json
{
	"name": "softball-ncaa-stats-team-results",
	"sections": [
		{
			"description": "Section contains the stats for the team.",
			"css": "html > body > table#dataTable > tr:nth-child(1) > td:nth-child(1)"
		},
		{
			"description": "Section contains the stats for the team statistical leaders.",
			"css": "html > body > div#contentContainer > div.container > div.row > div.col-md-12 > div:nth-child(1)  > div.table-responsive"
		},
	]
}
```

Your given html is:

```html
{{ .Content }}
```
{{- end -}}

{{/*
Identify Aggregate Template
================================================================================
*/}}
{{- define "identify_aggregate" -}}
As a diligent and experienced html developer, you are to create a structured json object that represents the sections of the given html content.
Your interns have created a list of json schemas for the given html content, but 
you must congregate them into a single comprehensive and accurate json response 
that fully describes the given html content.

You are to congregate the following json schemas into a single comprehensive and 
accurate json response that fully describes the given html content, and you must 
also provide a golang global struct name for the json response.

Example Output showing 2 sections and a golang global struct name:

```json
{
	"name": "SoftballNCAAStatsTeamResults",
	"sections": [
		{
			"description": "Section contains the stats for the team.",
			"css": "html > body > table#dataTable > tr:nth-child(1) > td:nth-child(1)"
		},
		{
			"description": "Section contains the stats for the team statistical leaders.",
			"css": "html > body > div#contentContainer > div.container > div.row > div.col-md-12 > div:nth-child(1)  > div.table-responsive"
		},
	]
}
```

Schemas:

{{- range $i, $schema := .Schemas }}
	{{- if $i }}{{- end }}
```json
{{ $schema }}
```
{{- end }}

The html is:

```html
{{ .Content }}
```
{{- end -}}

{{/*
Struct Prompt Template.
================================================================================
*/}}
{{- define "struct_prompt" -}}
As a diligent and experienced html developer, you are to generate a json schema
that fully describes the given html content for a given url, {{ .URL }}.

Your json schema must have a number of attributes for each field in the struct.

- name: the name of the field in the struct (should be a valid golang struct field name).
- type: the type of the field in the struct (should be a valid golang type).

- header selector: used to find the header row and column for the field in the given struct.
- data-selector: used to find the data column for the field in the given struct.
- query-selector: used to query for the inner text or attribute of the cell.
- control-selector: used to control what to query for the inner text or attribute of the cell.
- must-be-present: used to ensure that the field is present in the given url.

Example Output:

```go
{
	"fields": [
		{
			"name": "AverageExitVelocity",
			"type": "int",
			"description": "The average exit velocity of the player's hits on the team stats page in meters per second. (mps)",
			"header-selector": "tr:nth-child(1) td:nth-child(1)",
			"data-selector": "tr:not(:nth-child(2)) td",
			"control-selector": "$text",
			"query-selector": "$text",
			"must-be-present": "must"
		}
	]
}
```

Your html content:

{{ .Content }}

Your selectors with attriubutes (meaning without added specifiers; `:nth-child(1)`, `:not(:nth-child(2))`, etc):

```txt
{{- range $i, $selector := .Selectors }}
	{{- if $i }}{{- end }}
{{ $selector.Value }}
{{- end }}
```

{{- end -}}

{{/*
Struct Aggregate Template
================================================================================
*/}}
{{- define "struct_aggregate" -}}

You are to cogregate the following json schemas into a single comprehensive and accurate json schema designed to be used to select elements using css selectors.

- header selector: used to find the header row and column for the field in the given struct.
- data-selector: used to find the data column for the field in the given struct.
- query-selector: used to query for the inner text or attribute of the cell.
- control-selector: used to control what to query for the inner text or attribute of the cell.
- must-be-present: used to ensure that the field is present in the given url.

The valid base value selecors are:

{{- range $i, $sel := .Selectors }}
	{{- if $i }}{{- end }}
- {{ $sel.Value }}
{{- end }}

Your HTML content:

{{ .Content }}

Your json schemas:

{{ .Schemas }}
{{- end -}}

{{/*
Struct File Template
================================================================================
*/}}
{{- define "struct_file" -}}
package {{ .PackageName }}

// {{ .Name }} is a struct for a {{ .Name }}
// @url: {{ .URL }}
// @ignore-elements: {{ range $i, $element := .IgnoreElements }}{{ if $i }}, {{ end }}{{ $element }}{{ end }}
type {{ .Name }} struct {
	{{ range $i, $field := .Fields }}
		// {{ $field.Name }} - {{ $field.Description }}
		{{ $field.Name }} {{ $field.Type }} `json:"{{ $field.Name }}" hSel:"{{ $field.HeaderSelector }}" dSel:"{{ $field.DataSelector }}" ctl:"{{ $field.ControlSelector }}" {{ if $field.MustBePresent }}must:"{{ $field.MustBePresent }}"{{ end }}`
	{{ end }}
}}
{{- end -}}

{{/*
Test File Template
================================================================================
*/}}
{{- define "test_file" -}}
// Code generated by seltabls - DO NOT EDIT
//
// seltabls: version: v{{ .Version }}
package {{ .PackageName }}

import (
	_ "embed"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/conneroisu/seltabl/tools/seltabls/pkg/generate"
	"github.com/conneroisu/seltabl"
)

// {{ .Name }}Seltabl is the seltabl configuration for the {{ .Name }} struct.
//
//go:embed {{ .Name }}_seltabl.yaml
var {{ .Name }}Seltabl string

// Test{{ .Name }} tests the {{ .Name }} struct.
func Test{{ .Name }}(t *testing.T) {
	a := assert.New(t)
	// Read the configuration file.
	var config generate.ConfigFile
	err = generate.ReadConfigFile("{{ .Name }}_seltabl.yaml", &config)
	a.NoError(err)
	body := config.HTMLBody
	result, err := seltabl.NewFromString[{{ .Name }}](body)
	a.NoError(err)
	a.NotNil(result)
}
{{- end -}}
